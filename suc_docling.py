# -*- coding: utf-8 -*-
"""suc_docling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mN7DAeca1uQYN-OYOo6t8g5JilCpm3gk
"""







!pip install docling

from docling.document_converter import DocumentConverter

source = "https://arxiv.org/pdf/2408.09869"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"

from docling.document_converter import DocumentConverter

source = "/content/dol.pdf"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"

from docling.document_converter import DocumentConverter

source = "/content/1.pdf"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"



!pip install python-docx

from docling.document_converter import DocumentConverter
from docx import Document

# ... (كود تحويل الملفات كما هو) ...

# إنشاء مستند وورد جديد
document = Document()

# إضافة نتائج التحويل إلى المستند
document.add_paragraph(result.document.export_to_markdown())

# حفظ المستند
document.save("output.docx")

from docling.document_converter import DocumentConverter
from docx import Document



from docling.document_converter import DocumentConverter

source = "/content/1.pdf"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"






document = Document()

# إضافة نتائج التحويل إلى المستند
document.add_paragraph(result.document.export_to_markdown())

# حفظ المستند
document.save("output.docx")



from docling.document_converter import DocumentConverter
from docx import Document



from docling.document_converter import DocumentConverter

source = "/content/2408.09869v5.pdf"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"






document = Document()

# إضافة نتائج التحويل إلى المستند
document.add_paragraph(result.document.export_to_markdown())

# حفظ المستند
document.save("output.docx")

from docling.document_converter import DocumentConverter
from docx import Document



from docling.document_converter import DocumentConverter

source = "/content/2408.09869v5.pdf"  # document per local path or URL
converter = DocumentConverter()
result = converter.convert(source)
print(result.document.export_to_markdown())  # output: "## Docling Technical Report[...]"






document = Document()

# إضافة نتائج التحويل إلى المستند
document.add_paragraph(result.document.export_to_markdown())

# حفظ المستند
document.save("output.docx")

with open("output.md", "w") as file:
    file.write(result.document.export_to_markdown())

from docling.document_converter import DocumentConverter

source = "/content/2408.09869v5.pdf"  # استبدل your_file.pdf باسم ملفك
converter = DocumentConverter()
result = converter.convert(source)

with open("output.md", "w") as file:
    file.write(result.document.export_to_markdown())

"""## حفظ المخرجات الى ملف markdown"""

from docling.document_converter import DocumentConverter

source = "/content/1.pdf"  # استبدل your_file.pdf باسم ملفك
converter = DocumentConverter()
result = converter.convert(source)

with open("output1.md", "w") as file:
    file.write(result.document.export_to_markdown())

"""برنامج مايكروسوفت وورد يستخدم عدة آليات وتقنيات للحفاظ على العلاقة بين النص والرسم (أو أي كائن آخر مثل صورة أو شكل) عند حفظ الملف أو تحويله (مثلاً إلى PDF). إليك كيفية عمل ذلك:
نقاط الارتساء (Anchoring):
المفهوم الأساسي: كل كائن عائم (غير "سطري مع النص") في وورد يتم "إرساؤه" أو "ربطه" بفقرة معينة في النص. هذه هي الآلية الأساسية.
كيف يعمل: عندما تُدرج صورة وتختار لها خيار التفاف نص (مثل "مربع"، "ضيق"، "أمام النص"، "خلف النص")، يقوم وورد بربط هذه الصورة بفقرة. إذا تحركت هذه الفقرة (بسبب إضافة أو حذف نص قبلها)، تتحرك الصورة معها لتحافظ على موقعها النسبي بالنسبة لتلك الفقرة.
التحكم: يمكنك رؤية علامة المرساة إذا قمت بتفعيل خيار "إظهار علامات التنسيق" ثم تحديد الصورة. يمكنك حتى سحب هذه المرساة لربط الصورة بفقرة مختلفة.
خيارات تخطيط الكائن (Object Layout Options):
التفاف النص (Text Wrapping):
سطري مع النص (In Line with Text): يُعامل الكائن كحرف كبير ضمن النص. يتحرك مع النص تمامًا. هذا هو أبسط أشكال العلاقة.
مربع (Square)، ضيق (Tight)، عبر (Through): يلتف النص حول حدود الكائن.
أعلى وأسفل (Top and Bottom): يأخذ الكائن عرض الصفحة (أو العمود) ويظهر النص فوقه وأسفله.
خلف النص (Behind Text)، أمام النص (In Front of Text): يظهر الكائن بشكل مستقل عن تدفق النص، إما خلفه أو أمامه.
الموضع (Position):
الموضع النسبي: يمكنك تحديد موضع الكائن بالنسبة للفقرة المرتبط بها، الهامش، الصفحة، العمود، إلخ. (مثلاً: "في المنتصف بالنسبة للهامش الأيسر").
الموضع المطلق: يمكنك تحديد موضع دقيق على الصفحة.
خيارات إضافية: مثل "تحريك الكائن مع النص" (وهو مرتبط بالارتساء) و "تثبيت الموضع على الصفحة" (يلغي تحرك الكائن مع الفقرة المرتبط بها، ويثبته في مكان معين على الصفحة بغض النظر عن تغير النص).
تنسيق الملف (File Format - DOCX):
عندما تحفظ المستند بتنسيق DOCX (وهو تنسيق مبني على XML)، يتم تخزين كل هذه المعلومات (نوع الارتساء، خيارات الالتفاف، إحداثيات الموضع، حجم الكائن، بيانات الصورة نفسها أو رابط إليها) بشكل منظم داخل ملف XML.
عند فتح الملف، يقرأ وورد هذه البيانات ويعيد بناء الصفحة كما كانت، محافظًا على العلاقات بين النص والكائنات.
عند التحويل إلى PDF:
عندما تقوم بـ "حفظ باسم" أو "تصدير" المستند إلى PDF، يقوم وورد بعملية "ترجمة" للتخطيط.
الـ PDF مصمم للحفاظ على المظهر المرئي للمستند كما هو تمامًا.
يتم تحويل النص إلى كائنات نصية ذات مواضع ثابتة، والصور إلى كائنات صور ذات مواضع ثابتة على الصفحة.
العلاقات الديناميكية (مثل الارتساء بفقرة قد تتحرك) يتم "تجميدها" في الـ PDF. بمعنى أن الـ PDF يلتقط "لقطة شاشة" متقدمة للتخطيط.
يحاول وورد قدر الإمكان أن يجعل مظهر الـ PDF مطابقًا لما تراه على الشاشة في وورد.
التجميع (Grouping):
إذا كان لديك رسم يتكون من عدة أشكال ونصوص (مربعات نص)، يمكنك "تجميعها" معًا. هذا يجعلها تُعامل كوحدة واحدة، مما يسهل الحفاظ على علاقاتها الداخلية عند تحريكها أو تغيير حجمها.
باختصار:
يعتمد وورد بشكل أساسي على "الارتساء" لربط الكائنات (الرسوم والصور) بالفقرات النصية، بالإضافة إلى "خيارات التخطيط" التي تحدد كيفية تفاعل النص مع الكائن وموضع الكائن. يتم حفظ كل هذه المعلومات في بنية ملف DOCX، وعند التحويل إلى PDF، يتم تحويل هذا التخطيط الديناميكي إلى تمثيل مرئي ثابت.
نصائح للحفاظ على التنسيق بشكل أفضل:
استخدم "سطري مع النص" قدر الإمكان إذا كان الرسم صغيرًا ويمكن أن يتناسب مع تدفق النص. هذا هو الخيار الأكثر استقرارًا.
عند استخدام التفاف النص: تأكد من أن الصورة مرساة بالفقرة الصحيحة.
لتخطيطات معقدة: فكر في استخدام الجداول (مع إخفاء حدودها) أو مربعات النص لتنظيم المحتوى، ثم ضع الصور داخلها.
اختبر قبل التحويل النهائي: قم دائمًا بمراجعة ملف PDF الناتج للتأكد من أن كل شيء في مكانه الصحيح.
"""









from PIL import Image
import pytesseract
from docx import Document
from docx.shared import Inches
import os

# --- إعدادات Tesseract (قد تحتاج لتعديل المسار) ---
# مثال لنظام ويندوز، إذا لم يكن Tesseract في PATH
# pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
# مثال لنظام لينكس أو ماك (عادة لا تحتاج لهذا السطر إذا كان Tesseract في PATH)
# pytesseract.pytesseract.tesseract_cmd = r'/usr/local/bin/tesseract' # أو /usr/bin/tesseract

def extract_text_from_image(image_path, lang='ara+eng'):
    """
    يستخرج النص من الصورة باستخدام Tesseract OCR.
    """
    try:
        img = Image.open(image_path)
        text = pytesseract.image_to_string(img, lang=lang)
        return text
    except Exception as e:
        print(f"خطأ في استخلاص النص: {e}")
        return ""

def create_word_document(image_path, extracted_text, output_filename="output88.docx"):
    """
    ينشئ ملف وورد يحتوي على الصورة والنص المستخرج.
    "العلاقة" هنا هي أن كلاهما موجود في نفس المستند.
    """
    try:
        doc = Document()
        doc.add_heading('الصورة الأصلية والنص المستخرج', level=1)

        # إضافة الصورة الأصلية
        # يمكنك التحكم في حجم الصورة إذا أردت
        # للحفاظ على "الشكل" كما هو في الصورة، ندرج الصورة كاملة.
        doc.add_picture(image_path, width=Inches(6.0)) # عرض 6 بوصات كمثال

        doc.add_heading('النص المستخرج من الصورة:', level=2)
        doc.add_paragraph(extracted_text)

        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في إنشاء ملف الوورد: {e}")

def create_markdown_file(image_path, extracted_text, output_filename="output88.md"):
    """
    ينشئ ملف ماركداون يحتوي على الصورة والنص المستخرج.
    العلاقة هنا هي أن الصورة تسبق النص في الملف.
    """
    try:
        # يجب أن تكون الصورة في نفس مسار ملف الماركداون أو مسار نسبي صحيح
        image_filename = os.path.basename(image_path)

        md_content = f"# الصورة الأصلية والنص المستخرج\n\n"
        md_content += f"## الصورة الأصلية\n"
        md_content += f"![الرسم من الصورة]({image_filename})\n\n" # يفترض أن الصورة في نفس المجلد
        md_content += f"## النص المستخرج\n"
        md_content += f"```\n{extracted_text}\n```\n"

        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في إنشاء ملف الماركداون: {e}")

# --- البرنامج الرئيسي ---
if __name__ == "__main__":
    # ضع مسار الصورة التي تريد معالجتها هنا
    # تأكد أن الصورة تحتوي على نص عربي واضح وأشكال
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png" # <--- قم بتغيير هذا المسار

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        # 1. استخلاص النص من الصورة
        # استخدم 'ara' للغة العربية، 'eng' للإنجليزية، 'ara+eng' لكليهما
        text_content = extract_text_from_image(input_image_path, lang='ara')

        if text_content:
            print("\n--- النص المستخرج ---")
            print(text_content)
            print("---------------------\n")

            # 2. إنشاء ملف وورد
            # (افترض أن الصورة يجب أن تكون في نفس مجلد السكربت أو توفير المسار الكامل)
            word_output_path = "extracted_content.docx"
            create_word_document(input_image_path, text_content, word_output_path)

            # 3. إنشاء ملف ماركداون
            # (افترض أن الصورة يجب أن تكون في نفس مجلد السكربت أو توفير المسار الكامل)
            # لكي تعمل الصورة في الماركداون بشكل صحيح، قد تحتاج لنسخ الصورة إلى نفس مجلد الماركداون
            # أو استخدام مسار نسبي صحيح إذا كان ملف الماركداون في مكان مختلف.
            # هنا نفترض أن الصورة وملف الماركداون سيكونان في نفس مكان تشغيل السكربت.
            # إذا لم يكن كذلك، انسخ الصورة يدوياً أو برمجياً إلى جانب ملف الماركداون الناتج.

            # نسخ الصورة إلى مجلد الإخراج إذا كان ملف الماركداون سيوضع هناك
            # output_dir = os.path.dirname(os.path.abspath(__file__)) # مجلد السكربت الحالي
            # shutil.copy(input_image_path, os.path.join(output_dir, os.path.basename(input_image_path)))

            markdown_output_path = "extracted_content.md"
            create_markdown_file(input_image_path, text_content, markdown_output_path)
        else:
            print("لم يتم استخلاص أي نص من الصورة.")

!pip install python-docx Pillow lxml # lxml لتحليل hOCR إذا لم نستخدم parser docling الداخلي

!pip install lxml # lxml لتحليل hOCR إذا لم نستخدم parser docling الداخلي

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
#from docling.parser import HOCRParser # Import HOCRParser from docling.parser

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    """
    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR) # حذف المخرجات القديمة
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # أمر docling الأساسي للـ OCR.
    # قد تحتاج لتعديل هذا الأمر بناءً على كيفية تثبيت docling
    # أو إذا كنت تريد تحديد محرك OCR معين يدعمه docling.
    # بدون تحديد محرك، قد يستخدم docling الإعداد الافتراضي (الذي قد يكون Tesseract).
    cmd = ["docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling:")
            print(f"STDOUT: {stdout.decode('utf-8', errors='ignore')}")
            print(f"STDERR: {stderr.decode('utf-8', errors='ignore')}")
            return None
        else:
            print(f"Docling STDOUT: {stdout.decode('utf-8', errors='ignore')}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")
            # البحث عن ملف hOCR الناتج
            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None

    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'docling'. هل هو مثبت وفي PATH؟")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_docling(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام HOCRParser من docling ويستخرج النصوص وإحداثياتها.
    """
    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return []

    extracted_elements = [] # قائمة لتخزين (text, bbox)
    try:
        parser = HOCRParser()
        doc_layout = parser.parse(hocr_file_path)

        for page in doc_layout.pages:
            # يمكننا استخلاص على مستوى الكلمات، الأسطر، أو الكتل
            # لاستخلاص كتل نصية أكبر، قد يكون من الأفضل التجميع على مستوى البلوك
            for block in page.blocks: # Blocks can be text or image
                if block.block_type == "text": # أو أي نوع نصي آخر يحدده docling
                    block_text = ""
                    # تجميع النص من الأسطر والكلمات داخل البلوك
                    for line in block.lines:
                        line_text_parts = []
                        for word in line.words:
                            line_text_parts.append(word.text)
                        block_text += " ".join(line_text_parts) + "\n" # سطر جديد لكل سطر في البلوك

                    if block_text.strip():
                         # bbox هو (x1, y1, x2, y2)
                        extracted_elements.append({
                            "type": "text",
                            "text": block_text.strip(),
                            "bbox": block.bbox
                        })
                elif block.block_type == "image" or block.block_type == "figure": # أو أنواع صور أخرى
                    # docling قد يحفظ الصور المكتشفة في مجلد المخرجات
                    # يمكننا هنا فقط تسجيل إحداثياتها لاستخدامها لاحقًا
                    # إذا أردنا قصها من الصورة الأصلية
                     extracted_elements.append({
                        "type": "image_region",
                        "bbox": block.bbox,
                        # قد تحتاج لإيجاد مسار الصورة المقصوصة إذا قام docling بحفظها
                        # "image_path": os.path.join(DOCLING_OUTPUT_DIR, "images", ...)
                    })


        # ترتيب العناصر بناءً على موضعها الرأسي (y1) ثم الأفقي (x1)
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))
        return extracted_elements

    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR: {e}")
        return []


def create_word_from_elements(original_image_path, elements, output_filename="docling_output.docx"):
    """
    ينشئ ملف وورد. يحاول وضع الصورة الأصلية والنصوص المستخرجة.
    الحفاظ على "العلاقة" هنا سيكون تقريبيًا.
    """
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    # الخيار 1: إضافة الصورة الأصلية كاملة أولاً
    try:
        # الحصول على أبعاد الصورة الأصلية لمعرفة مقياس الإحداثيات
        with Image.open(original_image_path) as img:
            img_width_px, img_height_px = img.size

        doc.add_paragraph("الصورة الأصلية:")
        # قد تحتاج لتعديل حجم الصورة ليتناسب مع الصفحة
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    # الخيار 2: محاولة إضافة النصوص (و ربما أجزاء الصورة لاحقًا)
    # هذا الجزء يعتمد بشدة على كيفية رغبتك في تمثيل "العلاقة".
    # python-docx لا يسهل وضع العناصر في إحداثيات مطلقة.
    # الطريقة الأبسط هي إضافة النصوص كفقرات متتالية.

    text_content_combined = ""
    for element in elements:
        if element["type"] == "text":
            text_content_combined += element["text"] + "\n\n" # فصل بين الكتل النصية
        # التعامل مع element["type"] == "image_region" سيكون أكثر تعقيدًا:
        # ستحتاج لقص هذا الجزء من الصورة الأصلية وإضافته.
        # مثال:
        # elif element["type"] == "image_region":
        #     try:
        #         with Image.open(original_image_path) as img:
        #             cropped_img = img.crop(element["bbox"])
        #             # حفظ الصورة المقصوصة مؤقتًا لإضافتها
        #             temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"cropped_{element['bbox']}.png")
        #             cropped_img.save(temp_cropped_path)
        #             doc.add_picture(temp_cropped_path, width=Inches(2)) # مثال للحجم
        #             os.remove(temp_cropped_path) # حذف المؤقتة
        #     except Exception as e:
        #         print(f"خطأ في معالجة منطقة الصورة: {e}")


    if text_content_combined:
        doc.add_paragraph(text_content_combined)
    else:
        doc.add_paragraph("لم يتم استخراج نصوص أو تم استخراج نصوص فارغة.")

    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")


def create_markdown_from_elements(original_image_path, elements, output_filename="docling_output.md"):
    """
    ينشئ ملف ماركداون. يدرج الصورة الأصلية والنصوص.
    """
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    # يفترض أن الصورة ستكون في نفس مسار ملف الماركداون أو يتم توفير مسار نسبي صحيح.
    # لتبسيط الأمر، سنستخدم اسم الملف الأصلي.
    original_image_filename = os.path.basename(original_image_path)

    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename})\n\n"

    md_content += f"## النصوص المستخرجة\n"
    text_for_md = ""
    for element in elements:
        if element["type"] == "text":
            # في الماركداون، عرض النصوص ككتل متتالية هو الأسهل
            text_for_md += element["text"] + "\n\n---\n\n" # فصل بفاصل أفقي
        # يمكن أيضًا التعامل مع image_region هنا إذا تم قصها وحفظها كملفات منفصلة
        # elif element["type"] == "image_region" and element.get("image_path"):
        #     md_content += f"![جزء من الصورة]({os.path.basename(element['image_path'])})\n\n"


    if text_for_md:
        md_content += text_for_md
    else:
        md_content += "لم يتم استخراج نصوص.\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")

# --- البرنامج الرئيسي ---
if __name__ == "__main__":
    # ضع مسار الصورة التي تريد معالجتها هنا
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png" # <--- قم بتغيير هذا المسار

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        # 1. تنفيذ Docling OCR
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            # 2. تحليل مخرجات hOCR
            # إذا كنت تريد استخدام محلل hOCR الخاص بـ docling:
            extracted_data = parse_hocr_with_docling(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                for i, element in enumerate(extracted_data):
                    print(f"العنصر {i+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:100]}...") # طباعة جزء من النص
                print("------------------------------\n")

                # 3. إنشاء ملف وورد
                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, word_output_filename)

                # 4. إنشاء ملف ماركداون
                # لكي تعمل الصورة في الماركداون، تأكد من نسخها إلى جانب ملف الماركداون
                # أو عدّل المسار في create_markdown_from_elements
                # مثال لنسخ الصورة:
                # target_md_image_path = os.path.join(os.getcwd(), os.path.basename(input_image_path))
                # if not os.path.exists(target_md_image_path):
                #    shutil.copy(input_image_path, target_md_image_path)

                markdown_output_filename = "output_from_docling.md"
                create_markdown_from_elements(input_image_path, extracted_data, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

    # تنظيف مجلد المخرجات إذا أردت
    # if os.path.exists(DOCLING_OUTPUT_DIR):
    #     shutil.rmtree(DOCLING_OUTPUT_DIR)

!pip install docling --upgrade  # Upgrade to the latest version of docling

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
from docling.parser import HOCRParser # Import HOCRParser from docling.parser

# ... (Rest of the code remains the same) ...

!pip install docling --upgrade  # Upgrade to the latest version of docling

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
from docling import HOCRParser # Import HOCRParser from docling directly

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"
# ... (Rest of your code remains the same) ...

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    """
    if not os.path.exists(image_path): # تحقق إضافي للتأكد من وجود ملف الصورة
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR)
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # --- التعديل هنا ---
    # استدعاء docling كوحدة بايثون
    cmd = ["python", "-m", "docling", "ocr", image_path, DOCLING_OUTPUT_DIR]
    # --------------------

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        # استخدام subprocess.run للحصول على تحكم أفضل وانتظار اكتمال الأمر
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout:
                print(f"STDOUT:\n{process.stdout}")
            if process.stderr:
                print(f"STDERR:\n{process.stderr}") # stderr غالبًا ما يحتوي على معلومات الخطأ الفعلية
            return None
        else:
            if process.stdout:
                 print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr: # حتى مع النجاح، قد تكون هناك تحذيرات مفيدة في stderr
                print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            # البحث عن ملف hOCR الناتج
            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None

    except FileNotFoundError:
        # هذا الخطأ يحدث إذا لم يتم العثور على "python" نفسه، وهو أمر غير مرجح،
        # أو إذا كان "docling" غير مثبت كوحدة بشكل صحيح.
        print("خطأ: لم يتم العثور على أمر 'python' أو أن وحدة 'docling' غير مثبتة بشكل صحيح.")
        print("تأكد من تثبيت docling في بيئة بايثون الحالية: pip install docling")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
#from docling.parser import HOCRParser # Import HOCRParser from docling.parser

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    """
    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR) # حذف المخرجات القديمة
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # أمر docling الأساسي للـ OCR.
    # قد تحتاج لتعديل هذا الأمر بناءً على كيفية تثبيت docling
    # أو إذا كنت تريد تحديد محرك OCR معين يدعمه docling.
    # بدون تحديد محرك، قد يستخدم docling الإعداد الافتراضي (الذي قد يكون Tesseract).
    cmd = ["docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling:")
            print(f"STDOUT: {stdout.decode('utf-8', errors='ignore')}")
            print(f"STDERR: {stderr.decode('utf-8', errors='ignore')}")
            return None
        else:
            print(f"Docling STDOUT: {stdout.decode('utf-8', errors='ignore')}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")
            # البحث عن ملف hOCR الناتج
            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None

    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'docling'. هل هو مثبت وفي PATH؟")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_docling(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام HOCRParser من docling ويستخرج النصوص وإحداثياتها.
    """
    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return []

    extracted_elements = [] # قائمة لتخزين (text, bbox)
    try:
        parser = HOCRParser()
        doc_layout = parser.parse(hocr_file_path)

        for page in doc_layout.pages:
            # يمكننا استخلاص على مستوى الكلمات، الأسطر، أو الكتل
            # لاستخلاص كتل نصية أكبر، قد يكون من الأفضل التجميع على مستوى البلوك
            for block in page.blocks: # Blocks can be text or image
                if block.block_type == "text": # أو أي نوع نصي آخر يحدده docling
                    block_text = ""
                    # تجميع النص من الأسطر والكلمات داخل البلوك
                    for line in block.lines:
                        line_text_parts = []
                        for word in line.words:
                            line_text_parts.append(word.text)
                        block_text += " ".join(line_text_parts) + "\n" # سطر جديد لكل سطر في البلوك

                    if block_text.strip():
                         # bbox هو (x1, y1, x2, y2)
                        extracted_elements.append({
                            "type": "text",
                            "text": block_text.strip(),
                            "bbox": block.bbox
                        })
                elif block.block_type == "image" or block.block_type == "figure": # أو أنواع صور أخرى
                    # docling قد يحفظ الصور المكتشفة في مجلد المخرجات
                    # يمكننا هنا فقط تسجيل إحداثياتها لاستخدامها لاحقًا
                    # إذا أردنا قصها من الصورة الأصلية
                     extracted_elements.append({
                        "type": "image_region",
                        "bbox": block.bbox,
                        # قد تحتاج لإيجاد مسار الصورة المقصوصة إذا قام docling بحفظها
                        # "image_path": os.path.join(DOCLING_OUTPUT_DIR, "images", ...)
                    })


        # ترتيب العناصر بناءً على موضعها الرأسي (y1) ثم الأفقي (x1)
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))
        return extracted_elements

    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR: {e}")
        return []


def create_word_from_elements(original_image_path, elements, output_filename="docling_output.docx"):
    """
    ينشئ ملف وورد. يحاول وضع الصورة الأصلية والنصوص المستخرجة.
    الحفاظ على "العلاقة" هنا سيكون تقريبيًا.
    """
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    # الخيار 1: إضافة الصورة الأصلية كاملة أولاً
    try:
        # الحصول على أبعاد الصورة الأصلية لمعرفة مقياس الإحداثيات
        with Image.open(original_image_path) as img:
            img_width_px, img_height_px = img.size

        doc.add_paragraph("الصورة الأصلية:")
        # قد تحتاج لتعديل حجم الصورة ليتناسب مع الصفحة
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    # الخيار 2: محاولة إضافة النصوص (و ربما أجزاء الصورة لاحقًا)
    # هذا الجزء يعتمد بشدة على كيفية رغبتك في تمثيل "العلاقة".
    # python-docx لا يسهل وضع العناصر في إحداثيات مطلقة.
    # الطريقة الأبسط هي إضافة النصوص كفقرات متتالية.

    text_content_combined = ""
    for element in elements:
        if element["type"] == "text":
            text_content_combined += element["text"] + "\n\n" # فصل بين الكتل النصية
        # التعامل مع element["type"] == "image_region" سيكون أكثر تعقيدًا:
        # ستحتاج لقص هذا الجزء من الصورة الأصلية وإضافته.
        # مثال:
        # elif element["type"] == "image_region":
        #     try:
        #         with Image.open(original_image_path) as img:
        #             cropped_img = img.crop(element["bbox"])
        #             # حفظ الصورة المقصوصة مؤقتًا لإضافتها
        #             temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"cropped_{element['bbox']}.png")
        #             cropped_img.save(temp_cropped_path)
        #             doc.add_picture(temp_cropped_path, width=Inches(2)) # مثال للحجم
        #             os.remove(temp_cropped_path) # حذف المؤقتة
        #     except Exception as e:
        #         print(f"خطأ في معالجة منطقة الصورة: {e}")


    if text_content_combined:
        doc.add_paragraph(text_content_combined)
    else:
        doc.add_paragraph("لم يتم استخراج نصوص أو تم استخراج نصوص فارغة.")

    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")


def create_markdown_from_elements(original_image_path, elements, output_filename="docling_output.md"):
    """
    ينشئ ملف ماركداون. يدرج الصورة الأصلية والنصوص.
    """
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    # يفترض أن الصورة ستكون في نفس مسار ملف الماركداون أو يتم توفير مسار نسبي صحيح.
    # لتبسيط الأمر، سنستخدم اسم الملف الأصلي.
    original_image_filename = os.path.basename(original_image_path)

    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename})\n\n"

    md_content += f"## النصوص المستخرجة\n"
    text_for_md = ""
    for element in elements:
        if element["type"] == "text":
            # في الماركداون، عرض النصوص ككتل متتالية هو الأسهل
            text_for_md += element["text"] + "\n\n---\n\n" # فصل بفاصل أفقي
        # يمكن أيضًا التعامل مع image_region هنا إذا تم قصها وحفظها كملفات منفصلة
        # elif element["type"] == "image_region" and element.get("image_path"):
        #     md_content += f"![جزء من الصورة]({os.path.basename(element['image_path'])})\n\n"


    if text_for_md:
        md_content += text_for_md
    else:
        md_content += "لم يتم استخراج نصوص.\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")

# --- البرنامج الرئيسي ---
if __name__ == "__main__":
    # ضع مسار الصورة التي تريد معالجتها هنا
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png" # <--- قم بتغيير هذا المسار

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        # 1. تنفيذ Docling OCR
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            # 2. تحليل مخرجات hOCR
            # إذا كنت تريد استخدام محلل hOCR الخاص بـ docling:
            extracted_data = parse_hocr_with_docling(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                for i, element in enumerate(extracted_data):
                    print(f"العنصر {i+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:100]}...") # طباعة جزء من النص
                print("------------------------------\n")

                # 3. إنشاء ملف وورد
                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, word_output_filename)

                # 4. إنشاء ملف ماركداون
                # لكي تعمل الصورة في الماركداون، تأكد من نسخها إلى جانب ملف الماركداون
                # أو عدّل المسار في create_markdown_from_elements
                # مثال لنسخ الصورة:
                # target_md_image_path = os.path.join(os.getcwd(), os.path.basename(input_image_path))
                # if not os.path.exists(target_md_image_path):
                #    shutil.copy(input_image_path, target_md_image_path)

                markdown_output_filename = "output_from_docling.md"
                create_markdown_from_elements(input_image_path, extracted_data, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

    # تنظيف مجلد المخرجات إذا أردت
    # if os.path.exists(DOCLING_OUTPUT_DIR):
    #     shutil.rmtree(DOCLING_OUTPUT_DIR)





import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
from docling import HOCRParser # لاستخدام محلل hOCR الخاص بـ docling

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    يستخدم "python -m docling" لضمان التنفيذ الصحيح.
    """
    if not os.path.exists(image_path):
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR) # حذف المخرجات القديمة
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # استدعاء docling كوحدة بايثون
    cmd = ["python", "-m", "docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        # استخدام subprocess.run للحصول على تحكم أفضل وانتظار اكتمال الأمر
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout:
                print(f"STDOUT:\n{process.stdout}")
            if process.stderr:
                print(f"STDERR:\n{process.stderr}") # stderr غالبًا ما يحتوي على معلومات الخطأ الفعلية
            return None
        else:
            # حتى مع النجاح، قد تكون هناك تحذيرات مفيدة في stderr
            if process.stdout and process.stdout.strip(): # طباعة stdout إذا لم يكن فارغًا
                 print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr and process.stderr.strip(): # طباعة stderr إذا لم يكن فارغًا ويحتوي على تحذيرات
                print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            # البحث عن ملف hOCR الناتج
            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None

    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'python' أو أن وحدة 'docling' غير مثبتة بشكل صحيح.")
        print("تأكد من تثبيت docling في بيئة بايثون الحالية: pip install docling")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_docling(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام HOCRParser من docling ويستخرج النصوص وإحداثياتها.
    """
    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return []

    extracted_elements = [] # قائمة لتخزين العناصر المستخرجة
    try:
        parser = HOCRParser()
        doc_layout = parser.parse(hocr_file_path)

        for page in doc_layout.pages:
            for block in page.blocks:
                if block.block_type == "text":
                    block_text = ""
                    for line in block.lines:
                        line_text_parts = [word.text for word in line.words if word.text]
                        if line_text_parts:
                            block_text += " ".join(line_text_parts) + "\n"

                    if block_text.strip():
                        extracted_elements.append({
                            "type": "text",
                            "text": block_text.strip(),
                            "bbox": block.bbox
                        })
                elif block.block_type in ["image", "figure", "picture"]: # توسيع أنواع الصور المحتملة
                    # تحديد المسار المحتمل للصورة المكتشفة إذا قام docling بحفظها
                    # هذا جزء تخميني، قد تحتاج لتكييفه بناءً على مخرجات docling الفعلية
                    potential_image_filename = f"{os.path.splitext(os.path.basename(hocr_file_path))[0]}_img_{len(extracted_elements)}.png" # مثال
                    potential_image_path = os.path.join(DOCLING_OUTPUT_DIR, "images", potential_image_filename) # أو مجلد آخر يستخدمه docling

                    extracted_elements.append({
                        "type": "image_region",
                        "bbox": block.bbox,
                        "image_path": potential_image_path if os.path.exists(potential_image_path) else None
                    })

        # ترتيب العناصر بناءً على موضعها الرأسي (y1) ثم الأفقي (x1)
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))
        return extracted_elements

    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR: {e}")
        return []


def create_word_from_elements(original_image_path, elements, output_filename="docling_output.docx"):
    """
    ينشئ ملف وورد. يحاول وضع الصورة الأصلية والنصوص المستخرجة.
    الحفاظ على "العلاقة" هنا سيكون تقريبيًا.
    """
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    try:
        with Image.open(original_image_path) as img:
            img_width_px, img_height_px = img.size

        doc.add_paragraph("الصورة الأصلية:")
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    for i, element in enumerate(elements):
        if element["type"] == "text":
            doc.add_paragraph(f"كتلة نص ({i+1}):\n" + element["text"])
            doc.add_paragraph(f"(الإحداثيات: {element['bbox']})") # اختياري: إضافة الإحداثيات
            doc.add_paragraph("---")
        elif element["type"] == "image_region":
            doc.add_paragraph(f"منطقة صورة مكتشفة ({i+1}): (الإحداثيات: {element['bbox']})")
            if element.get("image_path") and os.path.exists(element["image_path"]):
                try:
                    doc.add_picture(element["image_path"], width=Inches(3)) # مثال للحجم
                    doc.add_paragraph(f"(من ملف: {os.path.basename(element['image_path'])})")
                except Exception as e_img:
                    print(f"خطأ في إضافة الصورة المكتشفة '{element['image_path']}' إلى الوورد: {e_img}")
            else:
                # إذا لم يتم العثور على الصورة المقصوصة، يمكن قصها من الأصلية
                try:
                    with Image.open(original_image_path) as img_orig:
                        # التأكد من أن الإحداثيات صحيحة (قد تكون نسبية أو مطلقة)
                        # docling عادة ما يعطي إحداثيات مطلقة بالنسبة للصورة
                        bbox = element['bbox']
                        # التأكد من أن الإحداثيات ضمن حدود الصورة
                        bbox = (
                            max(0, bbox[0]),
                            max(0, bbox[1]),
                            min(img_width_px, bbox[2]),
                            min(img_height_px, bbox[3])
                        )
                        if bbox[0] < bbox[2] and bbox[1] < bbox[3]: # التحقق من أن الصندوق صالح
                            cropped_img = img_orig.crop(bbox)
                            temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"temp_crop_{i}.png")
                            cropped_img.save(temp_cropped_path)
                            doc.add_picture(temp_cropped_path, width=Inches(3))
                            os.remove(temp_cropped_path)
                        else:
                            doc.add_paragraph("(إحداثيات المنطقة غير صالحة للقص)")
                except Exception as e_crop:
                     print(f"خطأ في قص وإضافة منطقة الصورة من الأصلية: {e_crop}")
            doc.add_paragraph("---")

    if not elements:
        doc.add_paragraph("لم يتم استخراج أي عناصر.")

    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")


def create_markdown_from_elements(original_image_path, elements, output_filename="docling_output.md"):
    """
    ينشئ ملف ماركداون. يدرج الصورة الأصلية والنصوص والمناطق المكتشفة.
    """
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    original_image_filename_for_md = os.path.basename(original_image_path)
    # قد تحتاج لنسخ الصورة إلى جانب ملف الماركداون أو استخدام مسار نسبي
    # نفترض هنا أنه سيكون في نفس المجلد

    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename_for_md})\n\n"

    md_content += f"## العناصر المستخرجة\n\n"
    if not elements:
        md_content += "لم يتم استخراج أي عناصر.\n"

    for i, element in enumerate(elements):
        md_content += f"### عنصر {i+1}: {element['type']}\n"
        md_content += f"*الإحداثيات: `{element['bbox']}`*\n\n"
        if element["type"] == "text":
            md_content += f"```text\n{element['text']}\n```\n\n"
        elif element["type"] == "image_region":
            if element.get("image_path") and os.path.exists(element["image_path"]):
                img_region_filename_for_md = os.path.basename(element["image_path"])
                # تأكد من نسخ هذه الصورة أيضًا إلى جانب ملف الماركداون
                md_content += f"![منطقة صورة مكتشفة]({img_region_filename_for_md})\n\n"
            else:
                # يمكن إضافة ملاحظة بأنه تم اكتشاف منطقة صورة ولكن لم يتم العثور على ملفها
                md_content += "(تم اكتشاف منطقة صورة، لكن لم يتم العثور على ملف صورة مقصوصة مرتبط بها. يمكن قصها من الصورة الأصلية باستخدام الإحداثيات أعلاه.)\n\n"
        md_content += "---\n\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")

# --- البرنامج الرئيسي ---
if __name__ == "__main__":
    # ضع مسار الصورة التي تريد معالجتها هنا
    input_image_path = "path/to/your/image_with_text_and_shape.png" # <--- قم بتغيير هذا المسار
    # مثال: input_image_path = "pvc_image.png" # إذا كانت الصورة في نفس مجلد السكربت

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        # 1. تنفيذ Docling OCR
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            # 2. تحليل مخرجات hOCR
            extracted_data = parse_hocr_with_docling(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                for i_el, element in enumerate(extracted_data):
                    print(f"العنصر {i_el+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:80].replace(chr(10), ' ')}...")
                    elif element['type'] == 'image_region' and element.get('image_path'):
                        print(f"  مسار الصورة المكتشفة: {element['image_path']}")
                print("------------------------------\n")

                # 3. إنشاء ملف وورد
                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, word_output_filename)

                # 4. إنشاء ملف ماركداون
                # لكي تعمل الصور في الماركداون، تأكد من نسخها إلى جانب ملف الماركداون
                # أو عدّل المسار في create_markdown_from_elements
                # نسخ الصورة الأصلية والصور المقصوصة (إذا وجدت) إلى جانب ملف الماركداون
                markdown_dir = os.getcwd() # أو أي مجلد آخر تختاره لملف الماركداون

                # نسخ الصورة الأصلية
                try:
                    shutil.copy(input_image_path, os.path.join(markdown_dir, os.path.basename(input_image_path)))
                except Exception as e_copy:
                    print(f"تنبيه: لم يتم نسخ الصورة الأصلية لملف الماركداون: {e_copy}")

                # نسخ الصور المكتشفة بواسطة docling (إذا تم حفظها بالفعل)
                for element in extracted_data:
                    if element['type'] == 'image_region' and element.get('image_path') and os.path.exists(element['image_path']):
                        try:
                            shutil.copy(element['image_path'], os.path.join(markdown_dir, os.path.basename(element['image_path'])))
                        except Exception as e_copy_region:
                            print(f"تنبيه: لم يتم نسخ منطقة الصورة '{element['image_path']}' لملف الماركداون: {e_copy_region}")

                markdown_output_filename = "output_from_docling.md"
                create_markdown_from_elements(input_image_path, extracted_data, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

    # تنظيف مجلد المخرجات إذا أردت، ولكن من الأفضل إبقاؤه للتحقق من مخرجات docling
    # if os.path.exists(DOCLING_OUTPUT_DIR):
    #     shutil.rmtree(DOCLING_OUTPUT_DIR)

"""https://github.com/docling-project/docling/blob/main/docs/v2.md"""

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
#from docling import HOCRParser # لاستخدام محلل hOCR الخاص بـ docling
#from .hocr_node import HOCRNode
import docling
#from docling.parsers import HOCRParser




# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    يستخدم "python -m docling" لضمان التنفيذ الصحيح.
    """
    if not os.path.exists(image_path):
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR) # حذف المخرجات القديمة
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # استدعاء docling كوحدة بايثون
    cmd = ["python", "-m", "docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        # استخدام subprocess.run للحصول على تحكم أفضل وانتظار اكتمال الأمر
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout:
                print(f"STDOUT:\n{process.stdout}")
            if process.stderr:
                print(f"STDERR:\n{process.stderr}") # stderr غالبًا ما يحتوي على معلومات الخطأ الفعلية
            return None
        else:
            # حتى مع النجاح، قد تكون هناك تحذيرات مفيدة في stderr
            if process.stdout and process.stdout.strip(): # طباعة stdout إذا لم يكن فارغًا
                 print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr and process.stderr.strip(): # طباعة stderr إذا لم يكن فارغًا ويحتوي على تحذيرات
                print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            # البحث عن ملف hOCR الناتج
            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None

    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'python' أو أن وحدة 'docling' غير مثبتة بشكل صحيح.")
        print("تأكد من تثبيت docling في بيئة بايثون الحالية: pip install docling")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_docling(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام HOCRParser من docling ويستخرج النصوص وإحداثياتها.
    """
    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return []

    extracted_elements = [] # قائمة لتخزين العناصر المستخرجة
    try:
        parser = HOCRParser()
        doc_layout = parser.parse(hocr_file_path)

        for page in doc_layout.pages:
            for block in page.blocks:
                if block.block_type == "text":
                    block_text = ""
                    for line in block.lines:
                        line_text_parts = [word.text for word in line.words if word.text]
                        if line_text_parts:
                            block_text += " ".join(line_text_parts) + "\n"

                    if block_text.strip():
                        extracted_elements.append({
                            "type": "text",
                            "text": block_text.strip(),
                            "bbox": block.bbox
                        })
                elif block.block_type in ["image", "figure", "picture"]: # توسيع أنواع الصور المحتملة
                    # تحديد المسار المحتمل للصورة المكتشفة إذا قام docling بحفظها
                    # هذا جزء تخميني، قد تحتاج لتكييفه بناءً على مخرجات docling الفعلية
                    potential_image_filename = f"{os.path.splitext(os.path.basename(hocr_file_path))[0]}_img_{len(extracted_elements)}.png" # مثال
                    potential_image_path = os.path.join(DOCLING_OUTPUT_DIR, "images", potential_image_filename) # أو مجلد آخر يستخدمه docling

                    extracted_elements.append({
                        "type": "image_region",
                        "bbox": block.bbox,
                        "image_path": potential_image_path if os.path.exists(potential_image_path) else None
                    })

        # ترتيب العناصر بناءً على موضعها الرأسي (y1) ثم الأفقي (x1)
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))
        return extracted_elements

    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR: {e}")
        return []


def create_word_from_elements(original_image_path, elements, output_filename="docling_output.docx"):
    """
    ينشئ ملف وورد. يحاول وضع الصورة الأصلية والنصوص المستخرجة.
    الحفاظ على "العلاقة" هنا سيكون تقريبيًا.
    """
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    try:
        with Image.open(original_image_path) as img:
            img_width_px, img_height_px = img.size

        doc.add_paragraph("الصورة الأصلية:")
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    for i, element in enumerate(elements):
        if element["type"] == "text":
            doc.add_paragraph(f"كتلة نص ({i+1}):\n" + element["text"])
            doc.add_paragraph(f"(الإحداثيات: {element['bbox']})") # اختياري: إضافة الإحداثيات
            doc.add_paragraph("---")
        elif element["type"] == "image_region":
            doc.add_paragraph(f"منطقة صورة مكتشفة ({i+1}): (الإحداثيات: {element['bbox']})")
            if element.get("image_path") and os.path.exists(element["image_path"]):
                try:
                    doc.add_picture(element["image_path"], width=Inches(3)) # مثال للحجم
                    doc.add_paragraph(f"(من ملف: {os.path.basename(element['image_path'])})")
                except Exception as e_img:
                    print(f"خطأ في إضافة الصورة المكتشفة '{element['image_path']}' إلى الوورد: {e_img}")
            else:
                # إذا لم يتم العثور على الصورة المقصوصة، يمكن قصها من الأصلية
                try:
                    with Image.open(original_image_path) as img_orig:
                        # التأكد من أن الإحداثيات صحيحة (قد تكون نسبية أو مطلقة)
                        # docling عادة ما يعطي إحداثيات مطلقة بالنسبة للصورة
                        bbox = element['bbox']
                        # التأكد من أن الإحداثيات ضمن حدود الصورة
                        bbox = (
                            max(0, bbox[0]),
                            max(0, bbox[1]),
                            min(img_width_px, bbox[2]),
                            min(img_height_px, bbox[3])
                        )
                        if bbox[0] < bbox[2] and bbox[1] < bbox[3]: # التحقق من أن الصندوق صالح
                            cropped_img = img_orig.crop(bbox)
                            temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"temp_crop_{i}.png")
                            cropped_img.save(temp_cropped_path)
                            doc.add_picture(temp_cropped_path, width=Inches(3))
                            os.remove(temp_cropped_path)
                        else:
                            doc.add_paragraph("(إحداثيات المنطقة غير صالحة للقص)")
                except Exception as e_crop:
                     print(f"خطأ في قص وإضافة منطقة الصورة من الأصلية: {e_crop}")
            doc.add_paragraph("---")

    if not elements:
        doc.add_paragraph("لم يتم استخراج أي عناصر.")

    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")


def create_markdown_from_elements(original_image_path, elements, output_filename="docling_output.md"):
    """
    ينشئ ملف ماركداون. يدرج الصورة الأصلية والنصوص والمناطق المكتشفة.
    """
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    original_image_filename_for_md = os.path.basename(original_image_path)
    # قد تحتاج لنسخ الصورة إلى جانب ملف الماركداون أو استخدام مسار نسبي
    # نفترض هنا أنه سيكون في نفس المجلد

    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename_for_md})\n\n"

    md_content += f"## العناصر المستخرجة\n\n"
    if not elements:
        md_content += "لم يتم استخراج أي عناصر.\n"

    for i, element in enumerate(elements):
        md_content += f"### عنصر {i+1}: {element['type']}\n"
        md_content += f"*الإحداثيات: `{element['bbox']}`*\n\n"
        if element["type"] == "text":
            md_content += f"```text\n{element['text']}\n```\n\n"
        elif element["type"] == "image_region":
            if element.get("image_path") and os.path.exists(element["image_path"]):
                img_region_filename_for_md = os.path.basename(element["image_path"])
                # تأكد من نسخ هذه الصورة أيضًا إلى جانب ملف الماركداون
                md_content += f"![منطقة صورة مكتشفة]({img_region_filename_for_md})\n\n"
            else:
                # يمكن إضافة ملاحظة بأنه تم اكتشاف منطقة صورة ولكن لم يتم العثور على ملفها
                md_content += "(تم اكتشاف منطقة صورة، لكن لم يتم العثور على ملف صورة مقصوصة مرتبط بها. يمكن قصها من الصورة الأصلية باستخدام الإحداثيات أعلاه.)\n\n"
        md_content += "---\n\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")

# --- البرنامج الرئيسي ---
if __name__ == "__main__":
    # ضع مسار الصورة التي تريد معالجتها هنا
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png" # <--- قم بتغيير هذا المسار
    # مثال: input_image_path = "pvc_image.png" # إذا كانت الصورة في نفس مجلد السكربت

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        # 1. تنفيذ Docling OCR
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            # 2. تحليل مخرجات hOCR
            extracted_data = parse_hocr_with_docling(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                for i_el, element in enumerate(extracted_data):
                    print(f"العنصر {i_el+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:80].replace(chr(10), ' ')}...")
                    elif element['type'] == 'image_region' and element.get('image_path'):
                        print(f"  مسار الصورة المكتشفة: {element['image_path']}")
                print("------------------------------\n")

                # 3. إنشاء ملف وورد
                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, word_output_filename)

                # 4. إنشاء ملف ماركداون
                # لكي تعمل الصور في الماركداون، تأكد من نسخها إلى جانب ملف الماركداون
                # أو عدّل المسار في create_markdown_from_elements
                # نسخ الصورة الأصلية والصور المقصوصة (إذا وجدت) إلى جانب ملف الماركداون
                markdown_dir = os.getcwd() # أو أي مجلد آخر تختاره لملف الماركداون

                # نسخ الصورة الأصلية
                try:
                    shutil.copy(input_image_path, os.path.join(markdown_dir, os.path.basename(input_image_path)))
                except Exception as e_copy:
                    print(f"تنبيه: لم يتم نسخ الصورة الأصلية لملف الماركداون: {e_copy}")

                # نسخ الصور المكتشفة بواسطة docling (إذا تم حفظها بالفعل)
                for element in extracted_data:
                    if element['type'] == 'image_region' and element.get('image_path') and os.path.exists(element['image_path']):
                        try:
                            shutil.copy(element['image_path'], os.path.join(markdown_dir, os.path.basename(element['image_path'])))
                        except Exception as e_copy_region:
                            print(f"تنبيه: لم يتم نسخ منطقة الصورة '{element['image_path']}' لملف الماركداون: {e_copy_region}")

                markdown_output_filename = "output_from_docling.md"
                create_markdown_from_elements(input_image_path, extracted_data, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

    # تنظيف مجلد المخرجات إذا أردت، ولكن من الأفضل إبقاؤه للتحقق من مخرجات docling
    # if os.path.exists(DOCLING_OUTPUT_DIR):
    #     shutil.rmtree(DOCLING_OUTPUT_DIR)

"""https://github.com/jlieth/hocr-parser





https://docling-project.github.io/docling/usage/#using-remote-services
"""

!pip install git+https://github.com/jlieth/hocr-parser

import docling
# dir(docling) # سيعرض الأسماء المتاحة مباشرة تحت docling
# help(docling) # قد يعطي معلومات أكثر تفصيلاً
# يمكنك محاولة استيراد وحدات فرعية محتملة إذا كنت تعرف أسماءها
# import docling.parsers # كمثال
# dir(docling.parsers)









"""https://docling-project.github.io/docling/usage/#limit-resource-usage"""

import urllib.request
from io import BytesIO
from docling.backend.html_backend import HTMLDocumentBackend
from docling.datamodel.base_models import InputFormat
from docling.datamodel.document import InputDocument

url = "https://en.wikipedia.org/wiki/Duck"
text = urllib.request.urlopen(url).read()
in_doc = InputDocument(
    path_or_stream=BytesIO(text),
    format=InputFormat.HTML,
    backend=HTMLDocumentBackend,
    filename="duck.html",
)
backend = HTMLDocumentBackend(in_doc=in_doc, path_or_stream=BytesIO(text))
dl_doc = backend.convert()
print(dl_doc.export_to_markdown())

from io import BytesIO
from docling.datamodel.base_models import DocumentStream
from docling.document_converter import DocumentConverter

buf = BytesIO(your_binary_stream)
source = DocumentStream(name="https://arxiv.org/pdf/2206.01062", stream=buf)
converter = DocumentConverter()
result = converter.convert(source)

from io import BytesIO
from docling.datamodel.base_models import DocumentStream
from docling.document_converter import DocumentConverter
import requests

# Assuming the PDF is accessible via a URL:
pdf_url = "https://arxiv.org/pdf/2206.01062"  # Replace with your actual URL or local file path

# Fetch the PDF content as binary data
response = requests.get(pdf_url)
response.raise_for_status()  # Raise an exception for bad responses

buf = BytesIO(response.content)  # Use the downloaded content

# If you have the PDF content as a local file, you can use:
# with open("/path/to/your/pdf.pdf", "rb") as f:
#     buf = BytesIO(f.read())

source = DocumentStream(name="/content/2408.09869v5.pdf", stream=buf)
converter = DocumentConverter()
result = converter.convert(source)

from pathlib import Path
from docling.document_converter import DocumentConverter

source = "https://arxiv.org/pdf/2408.09869"
converter = DocumentConverter()
result = converter.convert(source, max_num_pages=100, max_file_size=20971520)

!docling-tools models download

!pip install lxml beautifulsoup4

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
from lxml import etree # لاستخدام lxml لتحليل hOCR
import re # لاستخدام التعبيرات النمطية في تحليل title

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    يستخدم "python -m docling" لضمان التنفيذ الصحيح.
    """
    if not os.path.exists(image_path):
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR)
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    cmd = ["python", "-m", "docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout: print(f"STDOUT:\n{process.stdout}")
            if process.stderr: print(f"STDERR:\n{process.stderr}")
            return None
        else:
            if process.stdout and process.stdout.strip(): print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr and process.stderr.strip(): print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None
    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'python' أو أن وحدة 'docling' غير مثبتة بشكل صحيح.")
        print("تأكد من تثبيت docling في بيئة بايثون الحالية: pip install docling")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_lxml(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام lxml ويستخرج النصوص وإحداثياتها ومناطق الصور.
    """
    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return [], None

    extracted_elements = []
    page_dimensions = None

    try:
        parser = etree.HTMLParser(recover=True, encoding='utf-8') # تحديد الترميز
        tree = etree.parse(hocr_file_path, parser)
        root = tree.getroot()

        # محاولة العثور على عقدة تمثل الصفحة للحصول على الأبعاد الكلية
        page_node = root.find(".//div[@class='ocr_page']")
        if page_node is None: # محاولة بديلة إذا لم يتم العثور على ocr_page
            body_node = root.find("body")
            if body_node is not None: page_node = body_node


        if page_node is not None:
            title_attr = page_node.get("title", "")
            # مثال على title: "bbox 0 0 1200 1800; image "path/to/image.png""
            bbox_search = re.search(r'bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)', title_attr)
            if bbox_search:
                x1, y1, x2, y2 = map(int, bbox_search.groups())
                page_dimensions = (x2, y2) # استخدام x2, y2 كـ width, height مباشرة
                                         # أو (x2-x1, y2-y1) إذا كانت x1,y1 ليست دائمًا 0

        # البحث عن الكتل النصية الشائعة
        # XPath للعثور على عناصر ocr_par (فقرة) أو ocr_carea (منطقة محتوى)
        # أو ocr_line إذا لم تكن العناصر الأعلى مستوى متاحة أو مناسبة
        # هذا قد يحتاج لتعديل بناءً على بنية ملف hOCR الفعلي
        for node in root.xpath("//*[@class='ocr_par' or @class='ocr_carea' or @class='ocr_line']"):
            title = node.get("title", "")
            bbox_match = re.search(r'bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)', title)
            if not bbox_match:
                continue

            bbox = tuple(map(int, bbox_match.groups()))

            # استخلاص النص من العقدة الحالية وجميع العقد الفرعية النصية
            # استخدام //text() للحصول على كل النصوص داخل العقدة
            # ثم تجميعها وتنظيفها
            text_nodes = node.xpath(".//text()")
            raw_text = " ".join(tn.strip() for tn in text_nodes if tn.strip())
            clean_text = re.sub(r'\s+', ' ', raw_text).strip() # إزالة المسافات الزائدة

            if clean_text:
                # التحقق مما إذا كانت هذه الكتلة جزءًا من كتلة أكبر تم استخلاصها بالفعل
                # هذا لمنع التكرار إذا كنا نستخلص ocr_line داخل ocr_par
                is_redundant = False
                for el in extracted_elements:
                    if el["type"] == "text" and clean_text in el["text"] and el["bbox"] == bbox:
                        is_redundant = True
                        break
                if not is_redundant:
                    extracted_elements.append({
                        "type": "text",
                        "text": clean_text,
                        "bbox": bbox
                    })

        # البحث عن الصور (إذا كانت مميزة بوسم <img> أو فئة معينة)
        # هذا الجزء تخميني ويعتمد على كيفية تمييز docling للصور
        for img_node in root.xpath("//img[contains(@class, 'ocr_image') or contains(@class, 'ocr_figure')] | //div[contains(@class, 'ocr_image_container') or contains(@class, 'ocr_figure')]"):
            title = img_node.get("title", "")
            bbox_match = re.search(r'bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)', title)
            if bbox_match:
                img_bbox = tuple(map(int, bbox_match.groups()))
                # التحقق من عدم إضافة نفس منطقة الصورة أكثر من مرة
                is_duplicate_img = any(el["type"] == "image_region" and el["bbox"] == img_bbox for el in extracted_elements)
                if not is_duplicate_img:
                    extracted_elements.append({
                        "type": "image_region",
                        "bbox": img_bbox,
                        "image_path": None # سنعتمد على القص من الصورة الأصلية
                    })

        # ترتيب العناصر بناءً على موضعها الرأسي ثم الأفقي
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))

        # إذا لم يتم العثور على أبعاد الصفحة من hOCR، حاول تقديرها من أقصى إحداثيات العناصر
        if not page_dimensions and extracted_elements:
            max_x2 = 0
            max_y2 = 0
            for el in extracted_elements:
                if el["bbox"][2] > max_x2: max_x2 = el["bbox"][2]
                if el["bbox"][3] > max_y2: max_y2 = el["bbox"][3]
            if max_x2 > 0 and max_y2 > 0:
                page_dimensions = (max_x2, max_y2)

        return extracted_elements, page_dimensions

    except etree.XMLSyntaxError as e:
        print(f"خطأ في بناء جملة XML/HTML في ملف hOCR: {hocr_file_path} - {e}")
        try:
            with open(hocr_file_path, 'r', encoding='utf-8') as f_err:
                print("محتوى الملف (أول 1000 حرف):"); print(f_err.read(1000))
        except Exception: pass
        return [], None
    except Exception as e:
        print(f"خطأ عام في تحليل ملف hOCR باستخدام lxml: {e}")
        import traceback
        traceback.print_exc()
        return [], None


def create_word_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.docx"):
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    img_width_px, img_height_px = 0, 0
    if page_dimensions:
        img_width_px, img_height_px = page_dimensions
    else:
        try:
            with Image.open(original_image_path) as img:
                img_width_px, img_height_px = img.size
        except Exception as e_img_dim:
            print(f"تنبيه: لم يتمكن من الحصول على أبعاد الصورة الأصلية: {e_img_dim}")

    try:
        doc.add_paragraph("الصورة الأصلية:")
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    if not elements:
        doc.add_paragraph("لم يتم استخراج أي عناصر.")

    for i, element in enumerate(elements):
        doc.add_paragraph(f"--- عنصر {i+1} ---")
        doc.add_paragraph(f"النوع: {element['type']}")
        doc.add_paragraph(f"الإحداثيات (bbox): {element['bbox']}")

        if element["type"] == "text":
            doc.add_paragraph("النص:")
            doc.add_paragraph(element["text"])
        elif element["type"] == "image_region":
            doc.add_paragraph("منطقة صورة مكتشفة.")
            if img_width_px > 0 and img_height_px > 0:
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        # التأكد أن إحداثيات القص ضمن حدود الصورة
                        crop_box = (
                            max(0, bbox[0]),
                            max(0, bbox[1]),
                            min(img_width_px, bbox[2]),
                            min(img_height_px, bbox[3])
                        )
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]: # التحقق من أن الصندوق صالح
                            cropped_img = img_orig.crop(crop_box)
                            # تحديد عرض مناسب للصورة المقصوصة في الوورد
                            aspect_ratio = cropped_img.width / cropped_img.height if cropped_img.height > 0 else 1
                            display_width = Inches(min(3.0, 6.0 * (cropped_img.width / img_width_px if img_width_px > 0 else 1))) # تقدير حجم العرض

                            temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"temp_crop_word_{i}.png")
                            cropped_img.save(temp_cropped_path)
                            doc.add_picture(temp_cropped_path, width=display_width)
                            os.remove(temp_cropped_path)
                        else:
                             doc.add_paragraph("(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)")
                except Exception as e_crop:
                     print(f"خطأ في قص وإضافة منطقة الصورة {element['bbox']} من الأصلية: {e_crop}")
            else:
                doc.add_paragraph("(لا يمكن قص المنطقة: أبعاد الصورة الأصلية غير متاحة أو صفرية)")
    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")

def create_markdown_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.md"):
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    original_image_filename_for_md = os.path.basename(original_image_path)
    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename_for_md})\n\n"

    md_content += f"## العناصر المستخرجة\n\n"
    if not elements:
        md_content += "لم يتم استخراج أي عناصر.\n"

    img_width_px, img_height_px = 0,0
    if page_dimensions: img_width_px, img_height_px = page_dimensions

    for i, element in enumerate(elements):
        md_content += f"### عنصر {i+1}: {element['type']}\n"
        md_content += f"*الإحداثيات: `{element['bbox']}`*\n\n"
        if element["type"] == "text":
            md_content += f"```text\n{element['text']}\n```\n\n"
        elif element["type"] == "image_region":
            md_content += "منطقة صورة مكتشفة.\n"
            # قص وحفظ الصورة للماركداون
            if img_width_px > 0 and img_height_px > 0:
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        crop_box = (max(0, bbox[0]), max(0, bbox[1]), min(img_width_px, bbox[2]), min(img_height_px, bbox[3]))
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]:
                            cropped_img = img_orig.crop(crop_box)
                            md_crop_filename = f"md_crop_{i}_{os.path.basename(original_image_path)}"
                            md_crop_path = os.path.join(os.path.dirname(output_filename), md_crop_filename) # حفظ بجانب ملف الماركداون
                            cropped_img.save(md_crop_path)
                            md_content += f"![منطقة صورة مقصوصة {i}]({md_crop_filename})\n\n"
                        else:
                            md_content += "(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)\n\n"
                except Exception as e_md_crop:
                    print(f"خطأ في قص وحفظ منطقة الصورة {element['bbox']} للماركداون: {e_md_crop}")
                    md_content += "(خطأ أثناء محاولة قص الصورة للماركداون)\n\n"
            else:
                 md_content += "(لا يمكن قص المنطقة للماركداون: أبعاد الصورة الأصلية غير متاحة أو صفرية)\n\n"

        md_content += "---\n\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")


if __name__ == "__main__":
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png" # <--- عدل المسار هنا إذا لزم الأمر

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            # استخدام الدالة الجديدة لتحليل hOCR
            extracted_data, page_dims = parse_hocr_with_lxml(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                if page_dims:
                    print(f"أبعاد الصفحة المقدرة: {page_dims}")
                for i_el, element in enumerate(extracted_data):
                    print(f"العنصر {i_el+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:80].replace(chr(10), ' ')}...")
                print("------------------------------\n")

                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, page_dims, word_output_filename)

                markdown_dir = os.getcwd()
                # نسخ الصورة الأصلية لملف الماركداون
                try:
                    if not os.path.exists(os.path.join(markdown_dir, os.path.basename(input_image_path))):
                         shutil.copy(input_image_path, os.path.join(markdown_dir, os.path.basename(input_image_path)))
                except Exception as e_copy:
                    print(f"تنبيه: لم يتم نسخ الصورة الأصلية لملف الماركداون: {e_copy}")

                markdown_output_filename = os.path.join(markdown_dir, "output_from_docling.md")
                create_markdown_from_elements(input_image_path, extracted_data, page_dims, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
import re # لا يزال مفيدًا لبعض الحالات

# --- استيراد hocr-parser ---
try:
    # بناءً على بنية شائعة لمثل هذه المكتبات
    from hocr_parser import HocrParser # هذا هو الاستيراد الصحيح بناءً على مصدر المكتبة
except ImportError:
    print("خطأ: لم يتم العثور على مكتبة hocr-parser. تأكد من تثبيتها بشكل صحيح.")
    print("يمكنك تثبيتها باستخدام: pip install git+https://github.com/jlieth/hocr-parser")
    HocrParser = None # لكي لا يفشل الكود إذا لم يتم التثبيت

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path):
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    يستخدم "python -m docling" لضمان التنفيذ الصحيح.
    """
    if not os.path.exists(image_path):
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR)
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    cmd = ["python", "-m", "docling", "ocr", image_path, DOCLING_OUTPUT_DIR]

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout: print(f"STDOUT:\n{process.stdout}")
            if process.stderr: print(f"STDERR:\n{process.stderr}")
            return None
        else:
            if process.stdout and process.stdout.strip(): print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr and process.stderr.strip(): print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None
    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'python' أو أن وحدة 'docling' غير مثبتة بشكل صحيح.")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_hocr_library(hocr_file_path): # تم تغيير اسم الدالة
    """
    يحلل ملف hOCR باستخدام مكتبة hocr-parser (jlieth/hocr-parser)
    ويستخرج النصوص وإحداثياتها ومناطق الصور.
    """
    if HocrParser is None: # التحقق مما إذا كان الاستيراد ناجحًا
        print("مكتبة hocr-parser غير متوفرة. لا يمكن تحليل ملف hOCR.")
        return [], None

    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return [], None

    extracted_elements = []
    page_dimensions = None

    try:
        # استخدام HocrParser من مكتبة jlieth/hocr-parser
        parser = HocrParser(hocr_file_path) # تمرير مسار الملف مباشرة

        # الحصول على أبعاد الصفحة (إذا كانت المكتبة توفرها بسهولة)
        # عادة ما تكون على مستوى الصفحة الأولى
        if parser.pages:
            first_page = parser.pages[0]
            # تعتمد أسماء الخصائص على كيفية تعريفها في المكتبة
            # مثال: first_page.bbox قد يكون [x1, y1, x2, y2]
            if hasattr(first_page, 'bbox') and first_page.bbox:
                 x1, y1, x2, y2 = first_page.bbox
                 page_dimensions = (x2 - x1, y2 - y1) # width, height
            elif hasattr(first_page, 'width') and hasattr(first_page, 'height'):
                 page_dimensions = (first_page.width, first_page.height)


        for page in parser.pages:
            # استخلاص كتل النص (عادةً ما تكون فقرات أو مناطق)
            # قد توفر المكتبة وصولاً إلى ocr_area, ocr_par, ocr_line, ocrx_word
            # سنحاول استهداف كتل نصية ذات معنى (مثل الفقرات)
            if hasattr(page, 'paragraphs'): # إذا كانت المكتبة تميز الفقرات
                for para in page.paragraphs:
                    if hasattr(para, 'text') and hasattr(para, 'bbox') and para.text.strip():
                        extracted_elements.append({
                            "type": "text",
                            "text": para.text.strip(),
                            "bbox": para.bbox # يجب أن تكون الإحداثيات (x1, y1, x2, y2)
                        })
            elif hasattr(page, 'lines'): # إذا لم تكن الفقرات متاحة، ننتقل للأسطر
                 current_paragraph_text = ""
                 current_paragraph_bbox = None
                 for line in page.lines:
                    if hasattr(line, 'text') and hasattr(line, 'bbox') and line.text.strip():
                        # محاولة تجميع الأسطر في فقرات إذا أمكن (تبسيط هنا)
                        # سنضيف كل سطر كعنصر نصي منفصل حاليًا لتبسيط الأمر
                        # أو يمكنك محاولة تجميعها إذا كانت متقاربة
                        extracted_elements.append({
                            "type": "text",
                            "text": line.text.strip(),
                            "bbox": line.bbox
                        })
            # يمكنك إضافة منطق أكثر تفصيلاً لاستخلاص ocr_carea أو عناصر أخرى إذا لزم الأمر
            # بناءً على ما توفره المكتبة.

            # استخلاص مناطق الصور (إذا كانت المكتبة تميزها)
            # مثال: إذا كان هناك page.images أو شيء مشابه
            if hasattr(page, 'images'): # هذا تخمين، تحقق من وثائق المكتبة
                for img_element in page.images:
                    if hasattr(img_element, 'bbox'):
                        extracted_elements.append({
                            "type": "image_region",
                            "bbox": img_element.bbox,
                            "image_path": None # سنعتمد على القص
                        })
            # طريقة أخرى قد تكون البحث عن عناصر لها class معين إذا لم يكن هناك تمييز مباشر للصور
            # elif hasattr(page, 'elements_by_class'):
            #     for img_element in page.elements_by_class('ocr_image') or page.elements_by_class('ocr_figure'):
            #         if hasattr(img_element, 'bbox'):
            #             extracted_elements.append({
            #                 "type": "image_region",
            #                 "bbox": img_element.bbox,
            #                 "image_path": None
            #             })

        # ترتيب العناصر
        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))

        # إذا لم يتم العثور على أبعاد الصفحة، حاول تقديرها
        if not page_dimensions and extracted_elements:
            max_x2 = 0
            max_y2 = 0
            for el in extracted_elements:
                if el["bbox"][2] > max_x2: max_x2 = el["bbox"][2]
                if el["bbox"][3] > max_y2: max_y2 = el["bbox"][3]
            if max_x2 > 0 and max_y2 > 0:
                page_dimensions = (max_x2, max_y2)

        return extracted_elements, page_dimensions

    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR باستخدام مكتبة hocr-parser: {e}")
        import traceback
        traceback.print_exc()
        return [], None

# --- الدوال الأخرى (create_word_from_elements, create_markdown_from_elements) تبقى كما هي ---
# --- سأقوم بلصقها مرة أخرى للتأكد من أننا نستخدم النسخة الصحيحة ---

def create_word_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.docx"):
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling و hocr-parser', level=1)

    img_width_px, img_height_px = 0, 0
    if page_dimensions:
        img_width_px, img_height_px = page_dimensions
    else:
        try:
            with Image.open(original_image_path) as img:
                img_width_px, img_height_px = img.size
        except Exception as e_img_dim:
            print(f"تنبيه: لم يتمكن من الحصول على أبعاد الصورة الأصلية: {e_img_dim}")

    try:
        doc.add_paragraph("الصورة الأصلية:")
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة:', level=2)

    if not elements:
        doc.add_paragraph("لم يتم استخراج أي عناصر.")

    for i, element in enumerate(elements):
        doc.add_paragraph(f"--- عنصر {i+1} ---")
        doc.add_paragraph(f"النوع: {element['type']}")
        doc.add_paragraph(f"الإحداثيات (bbox): {element['bbox']}")

        if element["type"] == "text":
            doc.add_paragraph("النص:")
            doc.add_paragraph(element["text"])
        elif element["type"] == "image_region":
            doc.add_paragraph("منطقة صورة مكتشفة.")
            if img_width_px > 0 and img_height_px > 0:
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        crop_box = (
                            max(0, int(bbox[0])), max(0, int(bbox[1])),
                            min(img_width_px, int(bbox[2])), min(img_height_px, int(bbox[3]))
                        )
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]:
                            cropped_img = img_orig.crop(crop_box)
                            aspect_ratio = cropped_img.width / cropped_img.height if cropped_img.height > 0 else 1
                            display_width_inches = min(3.0, 6.0 * (cropped_img.width / img_width_px if img_width_px > 0 else 1))
                            display_width = Inches(display_width_inches if display_width_inches > 0.1 else 0.5) # Ensure minimum width

                            temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"temp_crop_word_{i}.png")
                            cropped_img.save(temp_cropped_path)
                            doc.add_picture(temp_cropped_path, width=display_width)
                            os.remove(temp_cropped_path)
                        else:
                             doc.add_paragraph("(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)")
                except Exception as e_crop:
                     print(f"خطأ في قص وإضافة منطقة الصورة {element['bbox']} من الأصلية: {e_crop}")
            else:
                doc.add_paragraph("(لا يمكن قص المنطقة: أبعاد الصورة الأصلية غير متاحة أو صفرية)")
    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")

def create_markdown_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.md"):
    md_content = f"# مستند تم إنشاؤه بواسطة Docling و hocr-parser\n\n"

    original_image_filename_for_md = os.path.basename(original_image_path)
    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename_for_md})\n\n"

    md_content += f"## العناصر المستخرجة\n\n"
    if not elements:
        md_content += "لم يتم استخراج أي عناصر.\n"

    img_width_px, img_height_px = 0,0
    if page_dimensions: img_width_px, img_height_px = page_dimensions

    for i, element in enumerate(elements):
        md_content += f"### عنصر {i+1}: {element['type']}\n"
        md_content += f"*الإحداثيات: `{element['bbox']}`*\n\n"
        if element["type"] == "text":
            md_content += f"```text\n{element['text']}\n```\n\n"
        elif element["type"] == "image_region":
            md_content += "منطقة صورة مكتشفة.\n"
            if img_width_px > 0 and img_height_px > 0:
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        crop_box = (
                            max(0, int(bbox[0])), max(0, int(bbox[1])),
                            min(img_width_px, int(bbox[2])), min(img_height_px, int(bbox[3]))
                        )
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]:
                            cropped_img = img_orig.crop(crop_box)
                            md_crop_filename = f"md_crop_{i}_{os.path.splitext(os.path.basename(original_image_path))[0]}.png"
                            md_crop_path = os.path.join(os.path.dirname(output_filename) or ".", md_crop_filename)
                            cropped_img.save(md_crop_path)
                            md_content += f"![منطقة صورة مقصوصة {i}]({md_crop_filename})\n\n"
                        else:
                            md_content += "(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)\n\n"
                except Exception as e_md_crop:
                    print(f"خطأ في قص وحفظ منطقة الصورة {element['bbox']} للماركداون: {e_md_crop}")
                    md_content += "(خطأ أثناء محاولة قص الصورة للماركداون)\n\n"
            else:
                 md_content += "(لا يمكن قص المنطقة للماركداون: أبعاد الصورة الأصلية غير متاحة أو صفرية)\n\n"
        md_content += "---\n\n"

    try:
        # التأكد من أن مسار الإخراج للماركداون صحيح
        if not os.path.dirname(output_filename) and output_filename: # إذا كان اسم ملف فقط
            output_filename = os.path.join(os.getcwd(), output_filename)
        elif not output_filename: # اسم ملف افتراضي إذا كان فارغًا
             output_filename = os.path.join(os.getcwd(), "output_from_docling.md")

        os.makedirs(os.path.dirname(output_filename), exist_ok=True) # التأكد من وجود المجلد
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")


if __name__ == "__main__":
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png"

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            if HocrParser: # التحقق مرة أخرى قبل الاستخدام
                extracted_data, page_dims = parse_hocr_with_hocr_library(hocr_output_file)
            else:
                print("لا يمكن المتابعة لأن HocrParser غير متاح.")
                extracted_data, page_dims = [], None

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                if page_dims: print(f"أبعاد الصفحة المقدرة: {page_dims}")
                for i_el, element in enumerate(extracted_data):
                    print(f"العنصر {i_el+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:80].replace(chr(10), ' ')}...")
                print("------------------------------\n")

                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, page_dims, word_output_filename)

                markdown_base_dir = os.getcwd()
                markdown_output_filename = os.path.join(markdown_base_dir, "output_from_docling.md")

                try:
                    target_original_image_md = os.path.join(markdown_base_dir, os.path.basename(input_image_path))
                    if not os.path.exists(target_original_image_md) or not os.path.samefile(input_image_path, target_original_image_md):
                         shutil.copy(input_image_path, target_original_image_md)
                except Exception as e_copy:
                    print(f"تنبيه: لم يتم نسخ الصورة الأصلية لملف الماركداون: {e_copy}")

                create_markdown_from_elements(input_image_path, extracted_data, page_dims, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")

!pip install git+https://github.com/jlieth/hocr-parser



"""https://github.com/docling-project/docling/blob/main/docs/v2.md"""

# Convert a single file to Markdown (default)
docling myfile.pdf

# Convert a single file to Markdown and JSON, without OCR
docling myfile.pdf --to json --to md --no-ocr

# Convert PDF files in input directory to Markdown (default)
docling ./input/dir --from pdf

# Convert PDF and Word files in input directory to Markdown and JSON
docling ./input/dir --from pdf --from docx --to md --to json --output ./scratch

# Convert all supported files in input directory to Markdown, but abort on first error
docling ./input/dir --output ./scratch --abort-on-error

import subprocess
import os
import shutil
from PIL import Image
from docx import Document
from docx.shared import Inches
import re # قد نحتاجه لاحقًا

# --- محاولة استيراد HOCRParser من docling.parsers ---
try:
    from docling.parsers import HOCRParser
    print("تم استيراد HOCRParser من docling.parsers بنجاح.")
except ImportError:
    print("تحذير: لم يتم العثور على HOCRParser في docling.parsers.")
    print("إذا فشل تحليل hOCR، قد تحتاج إلى تثبيت مكتبة تحليل hOCR متخصصة مثل 'hocr-parser' (jlieth/hocr-parser)")
    print("أو استخدام lxml/BeautifulSoup لتحليل ملف hOCR يدويًا.")
    HOCRParser = None # لكي لا يفشل الكود فورًا إذا لم يتم العثور عليه

# --- إعدادات ---
DOCLING_OUTPUT_DIR = "docling_output"

def run_docling_ocr(image_path): # <--- تأكد أن هذه الدالة محدثة
    """
    ينفذ أمر docling ocr على الصورة ويخزن المخرجات.
    يستدعي "docling" مباشرة.
    """
    if not os.path.exists(image_path):
        print(f"خطأ: ملف الصورة المدخل '{image_path}' غير موجود.")
        return None

    if os.path.exists(DOCLING_OUTPUT_DIR):
        shutil.rmtree(DOCLING_OUTPUT_DIR)
    os.makedirs(DOCLING_OUTPUT_DIR, exist_ok=True)

    # --- التعديل الأساسي هنا ---
    cmd = ["docling", "ocr", image_path, DOCLING_OUTPUT_DIR]
    # ---------------------------

    print(f"تنفيذ أمر Docling: {' '.join(cmd)}")
    try:
        process = subprocess.run(cmd, capture_output=True, text=True, check=False, encoding='utf-8', errors='ignore')

        if process.returncode != 0:
            print(f"خطأ أثناء تنفيذ Docling (رمز الخروج: {process.returncode}):")
            if process.stdout: print(f"STDOUT:\n{process.stdout}")
            if process.stderr: print(f"STDERR:\n{process.stderr}") # مهم جدًا هنا
            return None
        else:
            if process.stdout and process.stdout.strip(): print(f"Docling STDOUT:\n{process.stdout}")
            if process.stderr and process.stderr.strip(): print(f"Docling STDERR (تحذيرات محتملة):\n{process.stderr}")
            print(f"Docling أنجز بنجاح. المخرجات في: {DOCLING_OUTPUT_DIR}")

            for fname in os.listdir(DOCLING_OUTPUT_DIR):
                if fname.endswith(".hocr"):
                    return os.path.join(DOCLING_OUTPUT_DIR, fname)
            print("لم يتم العثور على ملف hOCR في المخرجات.")
            return None
    except FileNotFoundError:
        print("خطأ: لم يتم العثور على أمر 'docling'. هل هو مثبت بشكل صحيح وفي PATH؟")
        return None
    except Exception as e:
        print(f"حدث خطأ غير متوقع أثناء تشغيل Docling: {e}")
        return None

def parse_hocr_with_docling_internal_parser(hocr_file_path):
    """
    يحلل ملف hOCR باستخدام HOCRParser المفترض وجوده في docling.parsers
    ويستخرج النصوص وإحداثياتها ومناطق الصور.
    """
    if HOCRParser is None:
        print("HOCRParser من docling.parsers غير متاح. لا يمكن تحليل الملف بهذه الطريقة.")
        return [], None

    if not hocr_file_path or not os.path.exists(hocr_file_path):
        print(f"ملف HOCR غير موجود: {hocr_file_path}")
        return [], None

    extracted_elements = []
    page_dimensions = None

    try:
        parser = HOCRParser()
        doc_layout = parser.parse(hocr_file_path)

        if hasattr(doc_layout, 'pages') and doc_layout.pages:
            first_page = doc_layout.pages[0]
            if hasattr(first_page, 'bbox') and first_page.bbox:
                 x1, y1, x2, y2 = first_page.bbox
                 page_dimensions = (x2 - x1, y2 - y1)
            elif hasattr(first_page, 'width') and hasattr(first_page, 'height'):
                 page_dimensions = (first_page.width, first_page.height)

        for page in doc_layout.pages:
            for block in page.blocks:
                if block.block_type == "text":
                    block_text_content = ""
                    for line in block.lines:
                        word_texts = [word.text for word in line.words if hasattr(word, 'text') and word.text]
                        if word_texts:
                            block_text_content += " ".join(word_texts) + "\n"

                    if block_text_content.strip() and hasattr(block, 'bbox'):
                        extracted_elements.append({
                            "type": "text",
                            "text": block_text_content.strip(),
                            "bbox": block.bbox
                        })
                elif block.block_type in ["image", "figure", "picture"] and hasattr(block, 'bbox'):
                    extracted_elements.append({
                        "type": "image_region",
                        "bbox": block.bbox,
                        "image_path": None
                    })

        extracted_elements.sort(key=lambda el: (el["bbox"][1], el["bbox"][0]))
        return extracted_elements, page_dimensions

    except AttributeError as e_attr:
        print(f"خطأ سمة (AttributeError) أثناء استخدام HOCRParser من docling: {e_attr}")
        print("راجع وثائق docling أو استخدم dir() لفحص الكائنات.")
        return [], None
    except Exception as e:
        print(f"خطأ في تحليل ملف hOCR باستخدام HOCRParser من docling: {e}")
        import traceback
        traceback.print_exc()
        return [], None

def create_word_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.docx"):
    doc = Document()
    doc.add_heading('مستند تم إنشاؤه بواسطة Docling', level=1)

    img_width_px, img_height_px = 0, 0
    if page_dimensions:
        img_width_px, img_height_px = page_dimensions
    else:
        try:
            with Image.open(original_image_path) as img:
                img_width_px, img_height_px = img.size
        except Exception as e_img_dim:
            print(f"تنبيه: لم يتمكن من الحصول على أبعاد الصورة الأصلية: {e_img_dim}")

    try:
        doc.add_paragraph("الصورة الأصلية:")
        doc.add_picture(original_image_path, width=Inches(6.0))
        doc.add_page_break()
    except Exception as e:
        print(f"خطأ في إضافة الصورة الأصلية إلى الوورد: {e}")

    doc.add_heading('العناصر المستخرجة بواسطة Docling:', level=2)

    if not elements:
        doc.add_paragraph("لم يتم استخراج أي عناصر.")

    for i, element in enumerate(elements):
        doc.add_paragraph(f"--- عنصر {i+1} ---")
        doc.add_paragraph(f"النوع: {element['type']}")
        doc.add_paragraph(f"الإحداثيات (bbox): {element['bbox']}")

        if element["type"] == "text":
            doc.add_paragraph("النص:")
            doc.add_paragraph(element["text"])
        elif element["type"] == "image_region":
            doc.add_paragraph("منطقة صورة مكتشفة.")
            if img_width_px > 0 and img_height_px > 0 and element.get('bbox'):
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        crop_box = (
                            max(0, int(bbox[0])), max(0, int(bbox[1])),
                            min(img_width_px, int(bbox[2])), min(img_height_px, int(bbox[3]))
                        )
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]:
                            cropped_img = img_orig.crop(crop_box)
                            aspect_ratio = cropped_img.width / cropped_img.height if cropped_img.height > 0 else 1
                            display_width_inches = min(3.0, 6.0 * (cropped_img.width / img_width_px if img_width_px > 0 else 1))
                            display_width = Inches(display_width_inches if display_width_inches > 0.1 else 0.5)

                            temp_cropped_path = os.path.join(DOCLING_OUTPUT_DIR, f"temp_crop_word_{i}.png")
                            cropped_img.save(temp_cropped_path)
                            doc.add_picture(temp_cropped_path, width=display_width)
                            os.remove(temp_cropped_path)
                        else:
                             doc.add_paragraph("(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)")
                except Exception as e_crop:
                     print(f"خطأ في قص وإضافة منطقة الصورة {element['bbox']} من الأصلية: {e_crop}")
            elif not element.get('bbox'):
                doc.add_paragraph("(لم يتم توفير إحداثيات للمنطقة)")
            else:
                doc.add_paragraph("(لا يمكن قص المنطقة: أبعاد الصورة الأصلية غير متاحة أو صفرية)")
    try:
        doc.save(output_filename)
        print(f"تم حفظ ملف الوورد: {output_filename}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الوورد: {e}")

def create_markdown_from_elements(original_image_path, elements, page_dimensions, output_filename="docling_output.md"):
    md_content = f"# مستند تم إنشاؤه بواسطة Docling\n\n"

    original_image_filename_for_md = os.path.basename(original_image_path)
    md_content += f"## الصورة الأصلية\n"
    md_content += f"![الصورة الأصلية]({original_image_filename_for_md})\n\n"

    md_content += f"## العناصر المستخرجة\n\n"
    if not elements:
        md_content += "لم يتم استخراج أي عناصر.\n"

    img_width_px, img_height_px = 0,0
    if page_dimensions: img_width_px, img_height_px = page_dimensions
    else:
        try:
            with Image.open(original_image_path) as img:
                img_width_px, img_height_px = img.size
        except Exception: pass

    for i, element in enumerate(elements):
        md_content += f"### عنصر {i+1}: {element['type']}\n"
        md_content += f"*الإحداثيات: `{element['bbox']}`*\n\n"
        if element["type"] == "text":
            md_content += f"```text\n{element['text']}\n```\n\n"
        elif element["type"] == "image_region":
            md_content += "منطقة صورة مكتشفة.\n"
            if img_width_px > 0 and img_height_px > 0 and element.get('bbox'):
                try:
                    with Image.open(original_image_path) as img_orig:
                        bbox = element['bbox']
                        crop_box = (
                            max(0, int(bbox[0])), max(0, int(bbox[1])),
                            min(img_width_px, int(bbox[2])), min(img_height_px, int(bbox[3]))
                        )
                        if crop_box[0] < crop_box[2] and crop_box[1] < crop_box[3]:
                            cropped_img = img_orig.crop(crop_box)
                            md_crop_filename = f"md_crop_{i}_{os.path.splitext(os.path.basename(original_image_path))[0]}.png"
                            output_dir_md = os.path.dirname(output_filename) or os.getcwd()
                            md_crop_path = os.path.join(output_dir_md, md_crop_filename)

                            cropped_img.save(md_crop_path)
                            md_content += f"![منطقة صورة مقصوصة {i}]({md_crop_filename})\n\n"
                        else:
                            md_content += "(إحداثيات المنطقة غير صالحة للقص أو خارج الحدود)\n\n"
                except Exception as e_md_crop:
                    print(f"خطأ في قص وحفظ منطقة الصورة {element['bbox']} للماركداون: {e_md_crop}")
                    md_content += "(خطأ أثناء محاولة قص الصورة للماركداون)\n\n"
            elif not element.get('bbox'):
                md_content += "(لم يتم توفير إحداثيات للمنطقة)\n\n"
            else:
                 md_content += "(لا يمكن قص المنطقة للماركداون: أبعاد الصورة الأصلية غير متاحة أو صفرية)\n\n"
        md_content += "---\n\n"

    try:
        output_dir_md_final = os.path.dirname(output_filename) or os.getcwd()
        os.makedirs(output_dir_md_final, exist_ok=True)
        final_md_path = os.path.join(output_dir_md_final, os.path.basename(output_filename))

        with open(final_md_path, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"تم حفظ ملف الماركداون: {final_md_path}")
    except Exception as e:
        print(f"خطأ في حفظ ملف الماركداون: {e}")

if __name__ == "__main__":
    input_image_path = "/content/PVC-Structure-PhotoRoom.png-PhotoRoom.png"

    if not os.path.exists(input_image_path):
        print(f"خطأ: ملف الصورة '{input_image_path}' غير موجود.")
    else:
        hocr_output_file = run_docling_ocr(input_image_path)

        if hocr_output_file:
            extracted_data, page_dims = parse_hocr_with_docling_internal_parser(hocr_output_file)

            if not extracted_data:
                print("لم يتم استخلاص أية عناصر من ملف hOCR.")
            else:
                print(f"\n--- تم استخلاص {len(extracted_data)} عنصرًا ---")
                if page_dims: print(f"أبعاد الصفحة المقدرة من HOCRParser: {page_dims}")
                for i_el, element in enumerate(extracted_data):
                    print(f"العنصر {i_el+1}: النوع={element['type']}, الإحداثيات={element['bbox']}")
                    if element['type'] == 'text':
                        print(f"  النص (مقتطف): {element['text'][:80].replace(chr(10), ' ')}...")
                print("------------------------------\n")

                word_output_filename = "output_from_docling.docx"
                create_word_from_elements(input_image_path, extracted_data, page_dims, word_output_filename)

                markdown_base_dir = os.getcwd()
                markdown_output_filename = os.path.join(markdown_base_dir, "output_from_docling.md")

                try:
                    target_original_image_md = os.path.join(markdown_base_dir, os.path.basename(input_image_path))
                    if not os.path.exists(target_original_image_md) or not os.path.samefile(input_image_path, target_original_image_md):
                         shutil.copy(input_image_path, target_original_image_md)
                except Exception as e_copy:
                    print(f"تنبيه: لم يتم نسخ الصورة الأصلية لملف الماركداون: {e_copy}")

                create_markdown_from_elements(input_image_path, extracted_data, page_dims, markdown_output_filename)
        else:
            print("فشل Docling OCR أو لم يتم إنتاج ملف hOCR.")





















!docling /content/PVC-Structure-PhotoRoom.png-PhotoRoom.png --from image --to md --output /content

!docling --help

"""### شغال حول صورة بها نص وشكل الى ماركدون يتعدل عليه بنفس الل ف الصورة"""

!docling /content/PVC-Structure-PhotoRoom.png-PhotoRoom.png --from image --to md --output /content

!docling /content/2408.09869v5.pdf --from pdf --to md --output /content





!docling /content/wik2.pdf --from pdf --to md --output /content --ocr-lang eng

--ocr-lang

!docling /content/wik2.pdf --from pdf --to md --output /content --ocr-lang en

!docling --ocr-lang

!docling /content/wiki.pdf --from pdf --to md --output /content --ocr-engine --ocr-lang

!docling-tools models download

!docling /content/wiki.pdf --from pdf --to md --output /content --ocr-engine

!docling --help







!docling /content/z.png --from image --ocr-engine tesseract --ocr-lang ara --to md --output docling_output

!docling /content/z.png --from image --ocr-engine tesseract --ocr-lang ara --to html --output docling_output

!docling /content/z.png --from image --ocr-engine easyocr --ocr-lang ara --to md --output docling_output

"""https://github.com/docling-project/docling/issues/1304"""

import httpx

async_client = httpx.AsyncClient(timeout=6000.0)
url = "http://localhost:6001/v1alpha/convert/source"
payload = {
"options": {
"from_formats": ["pdf","image"],
"to_formats": ["md"],
"image_export_mode": "placeholder",
"do_ocr": True,
"pipeline": "standard",
"force_ocr": False,
"ocr_engine": "easyocr",
"ocr_lang": ["en"],
"pdf_backend": "dlparse_v2",
"table_mode": "fast",
"abort_on_error": False,
"return_as_file": False
},
"file_sources": [],
"http_sources": [
{"url": "https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/DESIGN%20SISTEM%20DAYA%20GERAK/Fundamentals%20of%20Rocket%20Propulsion.pdf"}
]
}

response = await async_client.post(url, json=payload)

data = response.json()

!nc -zv localhost 6001



#!pip install docling --upgrade  # Make sure docling is installed and up-to-date

from docling.document_converter import DocumentConverter

def convert_document(source_url, output_format="md"):
  """Converts a document from a URL to the specified output format.

  Args:
      source_url: The URL of the document to convert.
      output_format: The desired output format (e.g., "md", "html"). Defaults to "md".

  Returns:
      The converted document content as a string.
  """
  try:
    converter = DocumentConverter()
    result = converter.convert(source_url)
    if output_format == "md":
      return result.document.export_to_markdown()
    elif output_format == "html":
      return result.document.export_to_html()
    else:
      print(f"Unsupported output format: {output_format}")
      return None
  except Exception as e:
    print(f"Error converting document: {e}")
    return None

# Example usage:
source_url = "https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/DESIGN%20SISTEM%20DAYA%20GERAK/Fundamentals%20of%20Rocket%20Propulsion.pdf"
output_format = "md"  # Or "html"

converted_content = convert_document(source_url, output_format)

if converted_content:
  print(converted_content)
  # You can further save the converted content to a file if needed
  with open("output.md", "w", encoding="utf-8") as f:
    f.write(converted_content)

source_url = "/content/Fundamentals of Rocket Propulsion.pdf"  # Replace with the actual path









"""### شغال من صورة الى ماركدون عربى"""

!docling /content/z.png --from image --ocr-engine easyocr --ocr-lang ar --to md --output docling_output

!docling /content/wiki.pdf --from pdf --ocr-engine easyocr --ocr-lang ar --to md --output docling_output

!docling /content/wiki.pdf --from pdf --ocr-engine easyocr --ocr-lang ar --to md --output docling_output

"""aشغال حلو جدا"""

!time docling /content/wik2.pdf --pdf-backend dlparse_v4   --no-enrich-formula --force-ocr  --no-enrich-code  --ocr   --ocr-engine easyocr   --ocr-lang en   --device auto  --num-threads 8   --to md



"""https://github.com/docling-project/docling/issues/1236"""

time docling ./test01.pdf --pdf-backend dlparse_v4   --no-enrich-formula --force-ocr  --no-enrich-code  --ocr   --ocr-engine easyocr   --ocr-lang en   --device auto  --num-threads 8   --to md

"""https://github.com/docling-project/docling/issues/1456"""

docling --show-external-plugins

!docling --output "[your output path]" -v --pdf-backend dlparse_v2 --table-mode accurate --image-export-mode referenced  --artifacts-path=~/.cache/docling/models --enrich-picture-classes  [input file name] --ocr-engine tesseract --ocr-lang [lang code name]

"""https://github.com/felixdittrich92/docling-OCR-OnnxTR"""



"""https://docling-project.github.io/docling/installation/"""

For testing, I used the notebook from https://ds4sd.github.io/docling/examples/custom_convert/ and set the OCR language to German by configuring pipeline_options.ocr_options.lang = ["de"]







!pip install easyocr

!pip install docling --upgrade  # Make sure docling is installed and up-to-date

from docling.document_converter import DocumentConverter

def convert_document(source_url, output_format="md"):
  """Converts a document from a URL to the specified output format.

  Args:
      source_url: The URL of the document to convert.
      output_format: The desired output format (e.g., "md", "html"). Defaults to "md".

  Returns:
      The converted document content as a string.
  """
  try:
    converter = DocumentConverter()
    result = converter.convert(source_url)
    if output_format == "md":
      return result.document.export_to_markdown()
    elif output_format == "html":
      return result.document.export_to_html()
    else:
      print(f"Unsupported output format: {output_format}")
      return None
  except Exception as e:
    print(f"Error converting document: {e}")
    return None

# Example usage:
source_url = "https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/DESIGN%20SISTEM%20DAYA%20GERAK/Fundamentals%20of%20Rocket%20Propulsion.pdf"
output_format = "md"  # Or "html"

converted_content = convert_document(source_url, output_format)

if converted_content:
  print(converted_content)
  # You can further save the converted content to a file if needed
  with open("output.md", "w", encoding="utf-8") as f:
    f.write(converted_content)

from pathlib import Path

from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    TesseractCliOcrOptions,
)
from docling.document_converter import DocumentConverter, PdfFormatOption

inputData = "/content/wiki.pdf"
outputData = "/content/wiki.md"

ocr_options = TesseractCliOcrOptions(lang=["auto"])
pipeline_options = PdfPipelineOptions(
        do_ocr=True, force_full_page_ocr=True, ocr_options=ocr_options
    )
converter = DocumentConverter(
        format_options={
            InputFormat.PDF: PdfFormatOption(
                pipeline_options=pipeline_options,
            )
        }
    )

print("beginning data conversion...")

# ingest all pdfs in data
input_path = Path(inputData)
pathlist = input_path.rglob('*.pdf')
for input_file in pathlist:
    print("loading " + input_file.name + "...")
    doc = converter.convert(str(input_file)).document
    md = doc.export_to_markdown()

    outfileName = outputData + str(input_file.stem).strip() + ".md"
    print("written to " + outfileName)
    outfile = open(outfileName, "x")
    outfile.write(md)
    outfile.close()

print("data conversion complete")



from pathlib import Path
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    TesseractCliOcrOptions,
)
from docling.document_converter import DocumentConverter, PdfFormatOption

inputData = "/content/wiki.pdf"  # Make sure wiki.pdf is uploaded in Colab
outputData = "/content/"

ocr_options = TesseractCliOcrOptions(lang=["auto"])
pipeline_options = PdfPipelineOptions(
    do_ocr=True, force_full_page_ocr=True, ocr_options=ocr_options
)
converter = DocumentConverter(
    format_options={
        InputFormat.PDF: PdfFormatOption(
            pipeline_options=pipeline_options,
        )
    }
)

print("beginning data conversion...")

input_path = Path(inputData)
pathlist = input_path.rglob('*.pdf')
for input_file in pathlist:
    print("loading " + input_file.name + "...")
    print("Before conversion")  # Debugging print
    doc = converter.convert(str(input_file)).document
    print("After conversion")  # Debugging print
    md = doc.export_to_markdown()

    outfileName = outputData + str(input_file.stem).strip() + ".md"
    print("written to " + outfileName)
    outfile = open(outfileName, "w", encoding='utf-8')  # Changed to "w" mode
    outfile.write(md)
    outfile.close()

print("data conversion complete")

"""https://github.com/docling-project/docling/issues/1448"""



from pathlib import Path
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    TesseractCliOcrOptions,
)
from docling.document_converter import DocumentConverter, PdfFormatOption

inputData = "/content/BofA_InterestChecking_en_ADA.pdf"  # Make sure wiki.pdf is uploaded in Colab
outputData = "/content/"

# ... (Rest of the code is the same)

print("beginning data conversion...")

input_path = Path(inputData)
pathlist = input_path.rglob('*.pdf')
print(list(pathlist)) # Debugging print for pathlist
for input_file in pathlist:
    print(input_file)  # Debugging print for input_file
    print("loading " + input_file.name + "...")
    print("Before conversion")
    try:
        doc = converter.convert(str(input_file)).document
        print("Conversion successful")
    except Exception as e:
        print(f"Error during conversion: {e}")
    print("After conversion")
    md = doc.export_to_markdown()

    # ... (Rest of the code is the same)

print("data conversion complete")

from pathlib import Path
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    TesseractCliOcrOptions,
)
from docling.document_converter import DocumentConverter, PdfFormatOption

inputData = "/content/BofA_InterestChecking_en_ADA.pdf"  # Make sure wiki.pdf is uploaded in Colab
outputData = "/content/"

# ... (Rest of the code is the same)

print("beginning data conversion...")

input_path = Path('/content/') # Updated to search in /content/
pathlist = input_path.glob('*.pdf')  # Or use rglob to search subdirectories
for input_file in pathlist:
    print(input_file) # Debugging print for input_file
    print("loading " + input_file.name + "...")
    print("Before conversion")
    try:
        doc = converter.convert(str(input_file)).document
        print("Conversion successful")
    except Exception as e:
        print(f"Error during conversion: {e}")
    print("After conversion")
    md = doc.export_to_markdown()

    # ... (Rest of the code is the same)

print("data conversion complete")

